{
  "id": "aeaa2e38-515f-43c7-9a13-12b058ea2d8f",
  "_format": "hh-sol-build-info-1",
  "solcVersion": "0.7.4",
  "solcLongVersion": "0.7.4+commit.3f05b770",
  "input": {
    "language": "Solidity",
    "sources": {
      "contracts/dependencies/holyzeppelin/contracts/wip/libraries/datatypes/primitives/Uint256.sol": {
        "content": "// // SPDX-License-Identifier: AGPL-3.0-or-later\r\n// pragma solidity 0.7.4;\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\n// /**\r\n//  * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n//  * checks.\r\n//  *\r\n//  * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n//  * in bugs, because programmers usually assume that an overflow raises an\r\n//  * error, which is the standard behavior in high level programming languages.\r\n//  * `SafeMath` restores this intuition by reverting the transaction when an\r\n//  * operation overflows.\r\n//  *\r\n//  * Using this library instead of the unchecked operations eliminates an entire\r\n//  * class of bugs, so it's recommended to use it always.\r\n//  */\r\n//  // TODO needs versions for uint4, uint8, uint16, uint32, uint64, uint128, int4, int8, int16, int32, int64, int128, int256\r\n// library Uint256 {\r\n//     /**\r\n//      * @dev Returns the addition of two unsigned integers, reverting on\r\n//      * overflow.\r\n//      *\r\n//      * Counterpart to Solidity's `+` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Addition cannot overflow.\r\n//      */\r\n//     function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         uint256 c = a + b;\r\n//         require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the subtraction of two unsigned integers, reverting on\r\n//      * overflow (when the result is negative).\r\n//      *\r\n//      * Counterpart to Solidity's `-` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Subtraction cannot overflow.\r\n//      */\r\n//     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         return sub(a, b, \"SafeMath: subtraction overflow\");\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n//      * overflow (when the result is negative).\r\n//      *\r\n//      * Counterpart to Solidity's `-` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Subtraction cannot overflow.\r\n//      */\r\n//     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n//         require(b <= a, errorMessage);\r\n//         uint256 c = a - b;\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the multiplication of two unsigned integers, reverting on\r\n//      * overflow.\r\n//      *\r\n//      * Counterpart to Solidity's `*` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Multiplication cannot overflow.\r\n//      */\r\n//     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n//         // benefit is lost if 'b' is also tested.\r\n//         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n//         if (a == 0) {\r\n//             return 0;\r\n//         }\r\n\r\n//         uint256 c = a * b;\r\n//         require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the integer division of two unsigned integers. Reverts on\r\n//      * division by zero. The result is rounded towards zero.\r\n//      *\r\n//      * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n//      * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n//      * uses an invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         return div(a, b, \"SafeMath: division by zero\");\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n//      * division by zero. The result is rounded towards zero.\r\n//      *\r\n//      * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n//      * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n//      * uses an invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n//         require(b > 0, errorMessage);\r\n//         uint256 c = a / b;\r\n//         // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n//      * Reverts when dividing by zero.\r\n//      *\r\n//      * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n//      * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n//      * invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         return mod(a, b, \"SafeMath: modulo by zero\");\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n//      * Reverts with custom message when dividing by zero.\r\n//      *\r\n//      * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n//      * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n//      * invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n//         require(b != 0, errorMessage);\r\n//         return a % b;\r\n//     }\r\n\r\n//     // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n//     function sqrrt(uint256 a) internal pure returns (uint c) {\r\n//         if (a > 3) {\r\n//             c = a;\r\n//             uint b = add( div( a, 2), 1 );\r\n//             while (b < c) {\r\n//                 c = b;\r\n//                 b = div( add( div( a, b ), b), 2 );\r\n//             }\r\n//         } else if (a != 0) {\r\n//             c = 1;\r\n//         }\r\n//     }\r\n// }\r\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers"
          ],
          "": [
            "ast"
          ]
        }
      }
    }
  },
  "output": {
    "errors": [
      {
        "component": "general",
        "errorCode": "3420",
        "formattedMessage": "contracts/dependencies/holyzeppelin/contracts/wip/libraries/datatypes/primitives/Uint256.sol: Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.7.4;\"\n",
        "message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.7.4;\"",
        "severity": "warning",
        "sourceLocation": {
          "end": -1,
          "file": "contracts/dependencies/holyzeppelin/contracts/wip/libraries/datatypes/primitives/Uint256.sol",
          "start": -1
        },
        "type": "Warning"
      }
    ],
    "sources": {
      "contracts/dependencies/holyzeppelin/contracts/wip/libraries/datatypes/primitives/Uint256.sol": {
        "ast": {
          "absolutePath": "contracts/dependencies/holyzeppelin/contracts/wip/libraries/datatypes/primitives/Uint256.sol",
          "exportedSymbols": {},
          "id": 1,
          "license": "AGPL-3.0-or-later",
          "nodeType": "SourceUnit",
          "nodes": [],
          "src": "6458:0:0"
        },
        "id": 0
      }
    }
  }
}
