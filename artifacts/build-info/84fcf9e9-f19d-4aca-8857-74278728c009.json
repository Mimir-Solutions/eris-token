{
  "id": "84fcf9e9-f19d-4aca-8857-74278728c009",
  "_format": "hh-sol-build-info-1",
  "solcVersion": "0.7.4",
  "solcLongVersion": "0.7.4+commit.3f05b770",
  "input": {
    "language": "Solidity",
    "sources": {
      "contracts/dependencies/holyzeppelin/contracts/wip/abstract/RoleBasedAccessControl.sol": {
        "content": "// // SPDX-License-Identifier: AGPL-3.0-or-later\r\n// pragma solidity 0.7.4;\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\n// import \"../libraries/constants/Roles.sol\";\r\n// // import \"../libraries/dataTypes/primitives/Address.sol\";\r\n// // import \"../libraries/security/Context.sol\";\r\n// // import \"../libraries/dataTypes/collections/EnumerableSet.sol\";\r\n\r\n// /**\r\n//  * @dev Contract module that allows children to implement role-based access\r\n//  * control mechanisms.\r\n//  *\r\n//  * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n//  * in the external API and be unique. The best way to achieve this is by\r\n//  * using `public constant` hash digests:\r\n//  *\r\n//  * ```\r\n//  * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n//  * ```\r\n//  *\r\n//  * Roles can be used to represent a set of permissions. To restrict access to a\r\n//  * function call, use {hasRole}:\r\n//  *\r\n//  * ```\r\n//  * function foo() public {\r\n//  *     require(hasRole(MY_ROLE, msg.sender));\r\n//  *     ...\r\n//  * }\r\n//  * ```\r\n//  *\r\n//  * Roles can be granted and revoked dynamically via the {grantRole} and\r\n//  * {revokeRole} functions. Each role has an associated admin role, and only\r\n//  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n//  *\r\n//  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n//  * that only accounts with this role will be able to grant or revoke other\r\n//  * roles. More complex role relationships can be created by using\r\n//  * {_setRoleAdmin}.\r\n//  *\r\n//  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n//  * grant and revoke this role. Extra precautions should be taken to secure\r\n//  * accounts that have been granted it.\r\n//  */\r\n//  // *****************************************************************************************************\r\n//  // Should be turned into an Interface for clients to access both the AuthorizationPlatform and Authroization Datastore\r\n//  // *****************************************************************************************************\r\n// abstract contract RoleBasedAccessControl {\r\n\r\n//     // using EnumerableSet for EnumerableSet.AddressSet;\r\n//     // using EnumerableSet for EnumerableSet.Bytes32Set;\r\n//     // using Address for address;\r\n\r\n//     /**\r\n//      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n//      *\r\n//      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n//      * {RoleAdminChanged} not being emitted signaling this.\r\n//      *\r\n//      * _Available since v3.1._\r\n//      */\r\n//     // event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n//     // event RoleAdpproverChanged(bytes32 indexed role, bytes32 indexed previousApproverRole, bytes32 indexed newApproverRole);\r\n\r\n//     // event RestrictedSharedRoleAdded( bytes32 indexed roleWithRestrictedSharedRole, bytes32 indexed addedRestrictedSharedRole );\r\n\r\n//     /**\r\n//      * @dev Emitted when `account` is granted `role`.\r\n//      *\r\n//      * `sender` is the account that originated the contract call, an admin role\r\n//      * bearer except when using {_setupRole}.\r\n//      */\r\n//     // event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n//     // event RoleApproved( bytes32 indexed role, address indexed approver, address indexed account );\r\n\r\n//     // event ApprovalRevoked( bytes32 indexed role, address indexed approver, address indexed disapprovedAccount );\r\n\r\n//     /**\r\n//      * @dev Emitted when `account` is revoked `role`.\r\n//      *\r\n//      * `sender` is the account that originated the contract call:\r\n//      *   - if using `revokeRole`, it is the admin role bearer\r\n//      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n//      */\r\n//     // event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n//     // modifier onlyRole( bytes32 role_ ) {\r\n//     //     require( hasRole( role_, Context.Context._msgSender() ), \"RoleBasedAccessControl: account for not has authroized role for action.\" );\r\n//     //     _;\r\n//     // }\r\n\r\n//     // modifier notRole( bytes32 role_ ) {\r\n//     //     require( !hasRole( role_, Context.Context._msgSender() ) );\r\n//     //     _;\r\n//     // }\r\n    \r\n//     // struct RoleData {\r\n//     //     EnumerableSet.AddressSet members;\r\n//     //     bytes32 adminRole;\r\n//     //     bytes32 approverRole;\r\n//     //     EnumerableSet.Bytes32Set restrictedSharedRoles;\r\n//     //     mapping(address => bool) roleApproval;\r\n//     // }\r\n\r\n//     // mapping (bytes32 => RoleData) private _roles;\r\n\r\n//     constructor() {\r\n//         console.log( \"Instantiating RoleBasedAccessControl.\" );\r\n//         console.log( \"Instantiated RoleBasedAccessControl.\" );\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns `true` if `account` has been granted `role`.\r\n//      */\r\n//     function hasRole(bytes32 role, address account) public view returns (bool) {\r\n//         return _roles[role].members.contains(account);\r\n//     }\r\n\r\n//     function hasRestrictedSharedRole( bytes32 role, address challenger ) public view returns ( bool ) {\r\n\r\n//         for( uint8 iteration = 0; iteration < _roles[role].restrictedSharedRoles.length(); iteration++ ){\r\n//             if( _roles[_roles[role].restrictedSharedRoles.at( iteration )].members.contains( challenger ) ) {\r\n//                 return _roles[_roles[role].restrictedSharedRoles.at( iteration )].members.contains( challenger );\r\n//             }\r\n//         }\r\n\r\n//         return false;\r\n//     }\r\n\r\n//     function hasAnyOfRoles( bytes32[] storage roles_, address challenger ) internal view returns ( bool ) {\r\n\r\n//         for( uint8 iteration = 0; iteration <= roles_.length; iteration++ ){\r\n//             if( hasRole( roles_[iteration], challenger ) ){\r\n//                 return hasRole( roles_[iteration], challenger );\r\n//             }\r\n//         }\r\n\r\n//         return false;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the number of accounts that have `role`. Can be used\r\n//      * together with {getRoleMember} to enumerate all bearers of a role.\r\n//      */\r\n//     function getRoleMemberCount(bytes32 role) public view returns (uint256) {\r\n//         return _roles[role].members.length();\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns one of the accounts that have `role`. `index` must be a\r\n//      * value between 0 and {getRoleMemberCount}, non-inclusive.\r\n//      *\r\n//      * Role bearers are not sorted in any particular way, and their ordering may\r\n//      * change at any point.\r\n//      *\r\n//      * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\r\n//      * you perform all queries on the same block. See the following\r\n//      * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\r\n//      * for more information.\r\n//      */\r\n//     function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\r\n//         return _roles[role].members.at(index);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n//      * {revokeRole}.\r\n//      *\r\n//      * To change a role's admin, use {_setRoleAdmin}.\r\n//      */\r\n//     function getRoleAdmin(bytes32 role) public view returns (bytes32) {\r\n//         return _roles[role].adminRole;\r\n//     }\r\n\r\n//     function isApprovedForRole( bytes32 role, address queryAddress ) public view returns ( bool ) {\r\n//         return _isApproveForRole( role, queryAddress );\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Grants `role` to `account`.\r\n//      *\r\n//      * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n//      * event.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - the caller must have ``role``'s admin role.\r\n//      */\r\n//     function grantRole(bytes32 role, address account) public virtual {\r\n//         console.log(\"RoleBasedAccessControl::grantRole checking that %s is approved to have role.\", account );\r\n//         require( _isApproveForRole( role, account ), \"RoleBasedAccessControl::grantRole Address is not approved for role.\" );\r\n//         console.log(\"RoleBasedAccessControl::grantRole checking that %s is admin to set role.\", Context.Context._msgSender());\r\n//         require(hasRole(_roles[role].adminRole, Context.Context._msgSender()), \"RoleBasedAccessControl: sender must be an admin to grant\");\r\n//         console.log(\"RoleBasedAccessControl::grantRole checking that %s does not have any restricted shared roles for role.\", account);\r\n//         require( !hasRestrictedSharedRole( role, account ), \"RoleBasedAccessControl::grantRole account has restrictedSharedRoles with role.\" );\r\n//         console.log(\"RoleBasedAccessControl::grantRole Granting %s role.\", account);\r\n//         _grantRole(role, account);\r\n//         console.log(\"RoleBasedAccessControl::grantRole Granted %s role.\", account);\r\n//     }\r\n\r\n//     function approveForRole( bytes32 role, address approvedAccount ) public virtual {\r\n//         require( hasRole( _roles[role].approverRole, Context.Context._msgSender() ), \"RoleBasedAccessControl::approveForRole caller is not role approver.\" );\r\n//         _approveForRole( role, approvedAccount );\r\n//     }\r\n\r\n//     function revokeApproval( bytes32 role, address disapprovedAccount ) public virtual {\r\n//         require( hasRole( _roles[role].approverRole, Context.Context._msgSender() ), \"RoleBasedAccessControl::approveForRole caller is not role approver.\" );\r\n//         _revokeRoleApproval( role, disapprovedAccount );\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Revokes `role` from `account`.\r\n//      *\r\n//      * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - the caller must have ``role``'s admin role.\r\n//      */\r\n//     function revokeRole(bytes32 role, address account) public virtual {\r\n//         require(hasRole(_roles[role].adminRole, Context.Context._msgSender()), \"AccessControl: sender must be an admin to revoke\");\r\n\r\n//         _revokeRole(role, account);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Revokes `role` from the calling account.\r\n//      *\r\n//      * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n//      * purpose is to provide a mechanism for accounts to lose their privileges\r\n//      * if they are compromised (such as when a trusted device is misplaced).\r\n//      *\r\n//      * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n//      * event.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - the caller must be `account`.\r\n//      */\r\n//     function renounceRole(bytes32 role, address account) public virtual {\r\n//         require(account == Context.Context._msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n//         _revokeRole(role, account);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Grants `role` to `account`.\r\n//      *\r\n//      * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n//      * event. Note that unlike {grantRole}, this function doesn't perform any\r\n//      * checks on the calling account.\r\n//      *\r\n//      * [WARNING]\r\n//      * ====\r\n//      * This function should only be called from the constructor when setting\r\n//      * up the initial roles for the system.\r\n//      *\r\n//      * Using this function in any other way is effectively circumventing the admin\r\n//      * system imposed by {AccessControl}.\r\n//      * ====\r\n//      */\r\n//     function _setupRole(bytes32 role, address account) internal virtual {\r\n//         _grantRole(role, account);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Sets `adminRole` as ``role``'s admin role.\r\n//      *\r\n//      * Emits a {RoleAdminChanged} event.\r\n//      */\r\n//     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n//         emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\r\n//         _roles[role].adminRole = adminRole;\r\n//     }\r\n\r\n//     function _addRestrictedSharedRoles( bytes32 role, bytes32 restrictedSharedRole ) internal virtual {\r\n//         emit RestrictedSharedRoleAdded( role, restrictedSharedRole );\r\n//         _roles[role].restrictedSharedRoles.add( restrictedSharedRole );\r\n//     }\r\n\r\n//     function _setApproverRole( bytes32 role, bytes32 newApproverRole ) internal {\r\n//         emit RoleAdpproverChanged( role, _roles[role].approverRole, newApproverRole);\r\n//         _roles[role].approverRole = newApproverRole;\r\n//     }\r\n\r\n//     function _grantRole(bytes32 role, address account) private {\r\n//         console.log(\"RoleBasedAccessControl: Granting %s role.\", account);\r\n//         if (_roles[role].members.add(account)) {\r\n//             emit RoleGranted(role, account, Context.Context._msgSender());\r\n//         }\r\n//     }\r\n\r\n//     function _revokeRole(bytes32 role, address account) internal {\r\n//         if (_roles[role].members.remove(account)) {\r\n//             emit RoleRevoked(role, account, Context.Context._msgSender());\r\n//         }\r\n//     }\r\n\r\n//     function _approveForRole(bytes32 role, address approvedAccount) internal {\r\n//         emit RoleApproved( role, Context.Context._msgSender(), approvedAccount );\r\n//         _roles[role].roleApproval[approvedAccount] = true;\r\n//     }\r\n\r\n//     function _revokeRoleApproval( bytes32 role, address revokedAccount ) internal {\r\n//         emit ApprovalRevoked( role, Context.Context._msgSender(), revokedAccount );\r\n//         _roles[role].roleApproval[revokedAccount] = false;\r\n//     }\r\n\r\n//     function _isApproveForRole( bytes32 role, address queryAddress ) internal view returns ( bool ) {\r\n//         return _roles[role].roleApproval[queryAddress];\r\n//     }\r\n// }\r\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers"
          ],
          "": [
            "ast"
          ]
        }
      }
    }
  },
  "output": {
    "errors": [
      {
        "component": "general",
        "errorCode": "3420",
        "formattedMessage": "contracts/dependencies/holyzeppelin/contracts/wip/abstract/RoleBasedAccessControl.sol: Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.7.4;\"\n",
        "message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.7.4;\"",
        "severity": "warning",
        "sourceLocation": {
          "end": -1,
          "file": "contracts/dependencies/holyzeppelin/contracts/wip/abstract/RoleBasedAccessControl.sol",
          "start": -1
        },
        "type": "Warning"
      }
    ],
    "sources": {
      "contracts/dependencies/holyzeppelin/contracts/wip/abstract/RoleBasedAccessControl.sol": {
        "ast": {
          "absolutePath": "contracts/dependencies/holyzeppelin/contracts/wip/abstract/RoleBasedAccessControl.sol",
          "exportedSymbols": {},
          "id": 1,
          "license": "AGPL-3.0-or-later",
          "nodeType": "SourceUnit",
          "nodes": [],
          "src": "13895:0:0"
        },
        "id": 0
      }
    }
  }
}
