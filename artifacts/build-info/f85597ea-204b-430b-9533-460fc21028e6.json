{
  "id": "f85597ea-204b-430b-9533-460fc21028e6",
  "_format": "hh-sol-build-info-1",
  "solcVersion": "0.7.4",
  "solcLongVersion": "0.7.4+commit.3f05b770",
  "input": {
    "language": "Solidity",
    "sources": {
      "contracts/dependencies/holyzeppelin/contracts/wip/abstract/erc/ERC20/ERC20.sol": {
        "content": "// // SPDX-License-Identifier: MIT\r\n// pragma solidity 0.7.4;\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\n// import \"../libraries/security/Context.sol\";\r\n// import \"../interfaces/IERC20.sol\";\r\n// import \"../libraries/math/SafeFullMath.sol\";\r\n\r\n// /**\r\n//  * @dev Implementation of the {IERC20} interface.\r\n//  *\r\n//  * This implementation is agnostic to the way tokens are created. This means\r\n//  * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n//  * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n//  *\r\n//  * TIP: For a detailed writeup see our guide\r\n//  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n//  * to implement supply mechanisms].\r\n//  *\r\n//  * We have followed general OpenZeppelin guidelines: functions revert instead\r\n//  * of returning `false` on failure. This behavior is nonetheless conventional\r\n//  * and does not conflict with the expectations of ERC20 applications.\r\n//  *\r\n//  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n//  * This allows applications to reconstruct the allowance for all accounts just\r\n//  * by listening to said events. Other implementations of the EIP may not emit\r\n//  * these events, as it isn't required by the specification.\r\n//  *\r\n//  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n//  * functions have been added to mitigate the well-known issues around setting\r\n//  * allowances. See {IERC20-approve}.\r\n//  */\r\n// abstract contract ERC20 is IERC20 {\r\n//     using SafeFullMath for uint256;\r\n\r\n//     mapping (address => uint256) private _balances;\r\n\r\n//     mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n//     uint256 private _totalSupply;\r\n\r\n//     string private _name;\r\n//     string private _symbol;\r\n//     uint8 private _decimals;\r\n\r\n//     /**\r\n//      * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n//      * a default value of 18.\r\n//      *\r\n//      * To select a different value for {decimals}, use {_setupDecimals}.\r\n//      *\r\n//      * All three of these values are immutable: they can only be set once during\r\n//      * construction.\r\n//      */\r\n//     constructor ( string memory name_, string memory symbol_, uint8 decimals_ ) {\r\n        \r\n//         console.log( \"Instantiating ERC20.\" );\r\n//         console.log( \"Setting _name to %s.\", name_ );\r\n//         _name = name_;\r\n//         console.log( \"Set _name to %s.\", name() );\r\n//         console.log( \"Setting _symbol to %s.\", symbol_ );\r\n//         _symbol = symbol_;\r\n//         console.log( \"Set _symbol to %s.\", symbol() );\r\n//         console.log( \"Setting _decimals to %s.\", decimals_ );\r\n//         _decimals = decimals_;\r\n//         console.log( \"Set _decimals to %s.\", decimals() );\r\n//         console.log( \"Instantiating ERC20.\" );\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the name of the token.\r\n//      */\r\n//     function name() public view returns (string memory) {\r\n//         console.log( \"Returning _name value of %s.\", _name );\r\n//         return _name;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the symbol of the token, usually a shorter version of the\r\n//      * name.\r\n//      */\r\n//     function symbol() public view returns (string memory) {\r\n//         console.log( \"Returning _name value of %s.\", _symbol );\r\n//         return _symbol;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the number of decimals used to get its user representation.\r\n//      * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n//      * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n//      *\r\n//      * Tokens usually opt for a value of 18, imitating the relationship between\r\n//      * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n//      * called.\r\n//      *\r\n//      * NOTE: This information is only used for _display_ purposes: it in\r\n//      * no way affects any of the arithmetic of the contract, including\r\n//      * {IERC20-balanceOf} and {IERC20-transfer}.\r\n//      */\r\n//     function decimals() public view returns (uint8) {\r\n//         console.log( \"Returning _name value of %s.\", _decimals );\r\n//         return _decimals;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-totalSupply}.\r\n//      */\r\n//     function totalSupply() public view override returns (uint256) {\r\n//         console.log( \"Returning _name value of %s.\", _totalSupply );\r\n//         return _totalSupply;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-balanceOf}.\r\n//      */\r\n//     function balanceOf(address account) public view override returns (uint256) {\r\n//         console.log(\"Returning %s as balanceOf for %s.\", _balances[account], account);\r\n//         return _balances[account];\r\n//     }\r\n\r\n\r\n//     /**\r\n//      * @dev See {IERC20-transfer}.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `recipient` cannot be the zero address.\r\n//      * - the caller must have a balance of at least `amount`.\r\n//      */\r\n//     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n//         _transfer( Context.Context._msgSender(), recipient, amount);\r\n//         return true;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-allowance}.\r\n//      */\r\n//     function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n//         return _allowances[owner][spender];\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-approve}.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `spender` cannot be the zero address.\r\n//      */\r\n//     function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n//         _approve( Context.Context._msgSender(), spender, amount );\r\n//         return true;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-transferFrom}.\r\n//      *\r\n//      * Emits an {Approval} event indicating the updated allowance. This is not\r\n//      * required by the EIP. See the note at the beginning of {ERC20}.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `sender` and `recipient` cannot be the zero address.\r\n//      * - `sender` must have a balance of at least `amount`.\r\n//      * - the caller must have allowance for ``sender``'s tokens of at least\r\n//      * `amount`.\r\n//      */\r\n//     function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n//         _transfer(sender, recipient, amount);\r\n//         _approve(sender, Context.Context._msgSender(), _allowances[sender][Context.Context._msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n//         return true;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n//      *\r\n//      * This is an alternative to {approve} that can be used as a mitigation for\r\n//      * problems described in {IERC20-approve}.\r\n//      *\r\n//      * Emits an {Approval} event indicating the updated allowance.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `spender` cannot be the zero address.\r\n//      */\r\n//     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n//         _approve(Context.Context._msgSender(), spender, _allowances[Context.Context._msgSender()][spender].add(addedValue));\r\n//         return true;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n//      *\r\n//      * This is an alternative to {approve} that can be used as a mitigation for\r\n//      * problems described in {IERC20-approve}.\r\n//      *\r\n//      * Emits an {Approval} event indicating the updated allowance.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `spender` cannot be the zero address.\r\n//      * - `spender` must have allowance for the caller of at least\r\n//      * `subtractedValue`.\r\n//      */\r\n//     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n//         _approve(Context.Context._msgSender(), spender, _allowances[Context.Context._msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n//         return true;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n//      *\r\n//      * This is internal function is equivalent to {transfer}, and can be used to\r\n//      * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n//      *\r\n//      * Emits a {Transfer} event.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `sender` cannot be the zero address.\r\n//      * - `recipient` cannot be the zero address.\r\n//      * - `sender` must have a balance of at least `amount`.\r\n//      */\r\n//     function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n//         require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n//         require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n//         _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n//         _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n//         _balances[recipient] = _balances[recipient].add(amount);\r\n//         emit Transfer(sender, recipient, amount);\r\n//     }\r\n\r\n//     /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n//      * the total supply.\r\n//      *\r\n//      * Emits a {Transfer} event with `from` set to the zero address.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `to` cannot be the zero address.\r\n//      */\r\n//     function _mint(address account, uint256 amount) internal virtual {\r\n//         require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n//         _beforeTokenTransfer(address(0), account, amount);\r\n\r\n//         _totalSupply = _totalSupply.add(amount);\r\n//         _balances[account] = _balances[account].add(amount);\r\n//         emit Transfer(address(0), account, amount);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Destroys `amount` tokens from `account`, reducing the\r\n//      * total supply.\r\n//      *\r\n//      * Emits a {Transfer} event with `to` set to the zero address.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `account` cannot be the zero address.\r\n//      * - `account` must have at least `amount` tokens.\r\n//      */\r\n//     function _burn(address account, uint256 amount) internal virtual {\r\n//         require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n//         _beforeTokenTransfer(account, address(0), amount);\r\n\r\n//         _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n//         _totalSupply = _totalSupply.sub(amount);\r\n//         emit Transfer(account, address(0), amount);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n//      *\r\n//      * This internal function is equivalent to `approve`, and can be used to\r\n//      * e.g. set automatic allowances for certain subsystems, etc.\r\n//      *\r\n//      * Emits an {Approval} event.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `owner` cannot be the zero address.\r\n//      * - `spender` cannot be the zero address.\r\n//      */\r\n//     function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n//         require(owner != address(0), \"ERC20: approve from the zero address\");\r\n//         require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n//         _allowances[owner][spender] = amount;\r\n//         emit Approval(owner, spender, amount);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Sets {decimals} to a value other than the default one of 18.\r\n//      *\r\n//      * WARNING: This function should only be called from the constructor. Most\r\n//      * applications that interact with token contracts will not expect\r\n//      * {decimals} to ever change, and may work incorrectly if it does.\r\n//      */\r\n//     function _setupDecimals(uint8 decimals_) internal {\r\n//         _decimals = decimals_;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Hook that is called before any transfer of tokens. This includes\r\n//      * minting and burning.\r\n//      *\r\n//      * Calling conditions:\r\n//      *\r\n//      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n//      * will be to transferred to `to`.\r\n//      * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n//      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n//      * - `from` and `to` are never both zero.\r\n//      *\r\n//      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n//      */\r\n//     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n// }\r\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers"
          ],
          "": [
            "ast"
          ]
        }
      }
    }
  },
  "output": {
    "errors": [
      {
        "component": "general",
        "errorCode": "3420",
        "formattedMessage": "contracts/dependencies/holyzeppelin/contracts/wip/abstract/erc/ERC20/ERC20.sol: Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.7.4;\"\n",
        "message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.7.4;\"",
        "severity": "warning",
        "sourceLocation": {
          "end": -1,
          "file": "contracts/dependencies/holyzeppelin/contracts/wip/abstract/erc/ERC20/ERC20.sol",
          "start": -1
        },
        "type": "Warning"
      }
    ],
    "sources": {
      "contracts/dependencies/holyzeppelin/contracts/wip/abstract/erc/ERC20/ERC20.sol": {
        "ast": {
          "absolutePath": "contracts/dependencies/holyzeppelin/contracts/wip/abstract/erc/ERC20/ERC20.sol",
          "exportedSymbols": {},
          "id": 1,
          "license": "MIT",
          "nodeType": "SourceUnit",
          "nodes": [],
          "src": "12933:0:0"
        },
        "id": 0
      }
    }
  }
}
