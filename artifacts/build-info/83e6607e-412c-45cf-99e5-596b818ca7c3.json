{
  "id": "83e6607e-412c-45cf-99e5-596b818ca7c3",
  "_format": "hh-sol-build-info-1",
  "solcVersion": "0.7.4",
  "solcLongVersion": "0.7.4+commit.3f05b770",
  "input": {
    "language": "Solidity",
    "sources": {
      "contracts/dependencies/holyzeppelin/contracts/wip/abstract/AccessControl.sol": {
        "content": "// // SPDX-License-Identifier: AGPL-3.0-or-later\r\n// pragma solidity 0.7.4;\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\n// import \"../libraries/datatypes/collections/EnumerableSet.sol\";\r\n// import \"../libraries/datatypes/primitives/Address.sol\";\r\n// import \"./Context.sol\";\r\n\r\n// /**\r\n//  * @dev Contract module that allows children to implement role-based access\r\n//  * control mechanisms.\r\n//  *\r\n//  * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n//  * in the external API and be unique. The best way to achieve this is by\r\n//  * using `public constant` hash digests:\r\n//  *\r\n//  * ```\r\n//  * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n//  * ```\r\n//  *\r\n//  * Roles can be used to represent a set of permissions. To restrict access to a\r\n//  * function call, use {hasRole}:\r\n//  *\r\n//  * ```\r\n//  * function foo() public {\r\n//  *     require(hasRole(MY_ROLE, msg.sender));\r\n//  *     ...\r\n//  * }\r\n//  * ```\r\n//  *\r\n//  * Roles can be granted and revoked dynamically via the {grantRole} and\r\n//  * {revokeRole} functions. Each role has an associated admin role, and only\r\n//  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n//  *\r\n//  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n//  * that only accounts with this role will be able to grant or revoke other\r\n//  * roles. More complex role relationships can be created by using\r\n//  * {_setRoleAdmin}.\r\n//  *\r\n//  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n//  * grant and revoke this role. Extra precautions should be taken to secure\r\n//  * accounts that have been granted it.\r\n//  */\r\n// abstract contract AccessControl is Context {\r\n//     using EnumerableSet for EnumerableSet.AddressSet;\r\n//     using Address for address;\r\n\r\n//     struct RoleData {\r\n//         EnumerableSet.AddressSet members;\r\n//         bytes32 adminRole;\r\n//     }\r\n\r\n//     mapping (bytes32 => RoleData) internal _roles;\r\n\r\n//     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n//     /**\r\n//      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n//      *\r\n//      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n//      * {RoleAdminChanged} not being emitted signaling this.\r\n//      *\r\n//      * _Available since v3.1._\r\n//      */\r\n//     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n//     /**\r\n//      * @dev Emitted when `account` is granted `role`.\r\n//      *\r\n//      * `sender` is the account that originated the contract call, an admin role\r\n//      * bearer except when using {_setupRole}.\r\n//      */\r\n//     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n//     /**\r\n//      * @dev Emitted when `account` is revoked `role`.\r\n//      *\r\n//      * `sender` is the account that originated the contract call:\r\n//      *   - if using `revokeRole`, it is the admin role bearer\r\n//      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n//      */\r\n//     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n//     /**\r\n//      * @dev Returns `true` if `account` has been granted `role`.\r\n//      */\r\n//     function hasRole(bytes32 role, address account) public view returns (bool) {\r\n//         return _roles[role].members.contains(account);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the number of accounts that have `role`. Can be used\r\n//      * together with {getRoleMember} to enumerate all bearers of a role.\r\n//      */\r\n//     function getRoleMemberCount(bytes32 role) public view returns (uint256) {\r\n//         return _roles[role].members.length();\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns one of the accounts that have `role`. `index` must be a\r\n//      * value between 0 and {getRoleMemberCount}, non-inclusive.\r\n//      *\r\n//      * Role bearers are not sorted in any particular way, and their ordering may\r\n//      * change at any point.\r\n//      *\r\n//      * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\r\n//      * you perform all queries on the same block. See the following\r\n//      * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\r\n//      * for more information.\r\n//      */\r\n//     function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\r\n//         return _roles[role].members.at(index);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n//      * {revokeRole}.\r\n//      *\r\n//      * To change a role's admin, use {_setRoleAdmin}.\r\n//      */\r\n//     function getRoleAdmin(bytes32 role) public view returns (bytes32) {\r\n//         return _roles[role].adminRole;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Grants `role` to `account`.\r\n//      *\r\n//      * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n//      * event.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - the caller must have ``role``'s admin role.\r\n//      */\r\n//     function grantRole(bytes32 role, address account) public virtual {\r\n//         require(hasRole(_roles[role].adminRole, Context._msgSender()), \"AccessControl: sender must be an admin to grant\");\r\n\r\n//         _grantRole(role, account);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Revokes `role` from `account`.\r\n//      *\r\n//      * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - the caller must have ``role``'s admin role.\r\n//      */\r\n//     function revokeRole(bytes32 role, address account) public virtual {\r\n//         require(hasRole(_roles[role].adminRole, Context._msgSender()), \"AccessControl: sender must be an admin to revoke\");\r\n\r\n//         _revokeRole(role, account);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Revokes `role` from the calling account.\r\n//      *\r\n//      * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n//      * purpose is to provide a mechanism for accounts to lose their privileges\r\n//      * if they are compromised (such as when a trusted device is misplaced).\r\n//      *\r\n//      * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n//      * event.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - the caller must be `account`.\r\n//      */\r\n//     function renounceRole(bytes32 role, address account) public virtual {\r\n//         require(account == Context._msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n//         _revokeRole(role, account);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Grants `role` to `account`.\r\n//      *\r\n//      * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n//      * event. Note that unlike {grantRole}, this function doesn't perform any\r\n//      * checks on the calling account.\r\n//      *\r\n//      * [WARNING]\r\n//      * ====\r\n//      * This function should only be called from the constructor when setting\r\n//      * up the initial roles for the system.\r\n//      *\r\n//      * Using this function in any other way is effectively circumventing the admin\r\n//      * system imposed by {AccessControl}.\r\n//      * ====\r\n//      */\r\n//     function _setupRole(bytes32 role, address account) internal virtual {\r\n//         _grantRole(role, account);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Sets `adminRole` as ``role``'s admin role.\r\n//      *\r\n//      * Emits a {RoleAdminChanged} event.\r\n//      */\r\n//     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n//         emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\r\n//         _roles[role].adminRole = adminRole;\r\n//     }\r\n\r\n//     function _grantRole(bytes32 role, address account) private {\r\n//         if (_roles[role].members.add(account)) {\r\n//             emit RoleGranted(role, account, Context._msgSender());\r\n//         }\r\n//     }\r\n\r\n//     function _revokeRole(bytes32 role, address account) private {\r\n//         if (_roles[role].members.remove(account)) {\r\n//             emit RoleRevoked(role, account, Context._msgSender());\r\n//         }\r\n//     }\r\n// }\r\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers"
          ],
          "": [
            "ast"
          ]
        }
      }
    }
  },
  "output": {
    "errors": [
      {
        "component": "general",
        "errorCode": "3420",
        "formattedMessage": "contracts/dependencies/holyzeppelin/contracts/wip/abstract/AccessControl.sol: Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.7.4;\"\n",
        "message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.7.4;\"",
        "severity": "warning",
        "sourceLocation": {
          "end": -1,
          "file": "contracts/dependencies/holyzeppelin/contracts/wip/abstract/AccessControl.sol",
          "start": -1
        },
        "type": "Warning"
      }
    ],
    "sources": {
      "contracts/dependencies/holyzeppelin/contracts/wip/abstract/AccessControl.sol": {
        "ast": {
          "absolutePath": "contracts/dependencies/holyzeppelin/contracts/wip/abstract/AccessControl.sol",
          "exportedSymbols": {},
          "id": 1,
          "license": "AGPL-3.0-or-later",
          "nodeType": "SourceUnit",
          "nodes": [],
          "src": "8329:0:0"
        },
        "id": 0
      }
    }
  }
}
